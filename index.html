<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêõ Days of October üêõ</title>
    <style>
        @font-face {
            font-family: LinksAwakening;
            src: url("assets/the-legend-of-zelda-links-awakening-gb.otf") format("opentype");
        }

        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            font-family: LinksAwakening, sans-serif;

            box-sizing: border-box;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            width: 450px;
        }

        .bubble {
            clip-path: circle(50px at center);
            position: absolute;
        }
        
        h1 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .score {
            font-size: 20px;
            margin-bottom: 10px;
            color: #555;
        }
        
        canvas {
            border: 2px solid #333;
            background: #f0f0f0;
            display: block;
        }
        
        .controls {
            margin-top: 15px;
            color: #666;
            font-size: 14px;
        }

        .blurb {
            color: #666;
            margin-top: 30px;
            font-size: 14px;
        }
        
        .game-over {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: #ff6b6b;
            color: white;
            border-radius: 5px;
            font-weight: bold;

            width: 300px;
            position: fixed;
            top: 300px;
            text-align: center;
        }

        #holiday-container {
            color: #666;
            font-size: 14px;
            margin-bottom: 40px;
            height: 44px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>October <span id="score">1</span></h1>
        <div id="holiday-container">
            <span id="holiday">There is nothing designated for this day.</span>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div class="controls">Use Arrow Keys to move | Press Space to restart</div>

        <div class="blurb">
            Inspired by the Wikipedia pages <a href="https://en.wikipedia.org/wiki/List_of_food_days#October">List of food days</a> and <a href="https://en.wikipedia.org/wiki/List_of_environmental_dates">List of environmental dates</a>.
        </div>

        <div class="blurb">
            Created for the first ever <a href="https://wikigamejam.org/">WikiGameJam</a> by <a href="https://lyuu.cc/">‚û§ Lucy</a>, <a href="https://justinliang.me">‚û§ Justin</a>, <a href="https://amandayeh.com">‚û§ Amanda</a>, and <a href="https://mellyeliu.online">‚û§ Melly</a>!
        </div>
        
        <div class="game-over" id="gameOver">Game Over! Press Space to restart</div>
    </div>

<!--     <iframe
        class="bubble"
        height="100"
        width="100"
        src="https://en.wikipedia.org/wiki/Octopus"
    /> -->

    <script>
        const kvArray = [
          // [1, "It's International Raccoon Appreciation Day!"],
          [2, "It's World Farm Animals Day!"],
          [8, "It's World Octopus Day!"],
          [9, "It's International Beer and Pizza Day!"],
          [17, "It's International Sawfish Day!"],
          [21, "It's World Earthworm Day!"],
          [22, "It's International Wombat Day!"],
          [24, "It's Freshwater Dolphin Day!"],
          [30, "It's National Candy Corn Day!"],
          [31, "It's World Lemur Day!"]
        ];
        const dayMap = new Map(kvArray);

        const numLinkArray = [
          [2, "https://en.wikipedia.org/wiki/World_Day_for_Farmed_Animals"],
          [],
        ];

        const noVal = "There is nothing designated for this day.";


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const dayEl = document.getElementById('holiday');
        const gameOverEl = document.getElementById('gameOver');
        
        // High resolution canvas setup
        const scale = 4; // Increase for even higher resolution
        canvas.width = 400 * scale;
        canvas.height = 400 * scale;
        canvas.style.width = '400px';
        canvas.style.height = '400px';
        ctx.scale(scale, scale);
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        const gridSize = 20;
        const tileCount = 400 / gridSize;
        const imageSize = 30; // Images will be 30px (1.5x grid size) to create overlap
        const imageOffset = (gridSize - imageSize) / 2; // Center the larger image
        
        let snake = [{x: 10, y: 10}];
        let dx = 0;
        let dy = 0;
        let food = {x: 15, y: 15};
        let score = 1;
        let gameRunning = false;
        let gameSpeed = 100;
        
        // Image storage
        let headImg = new Image();
        headImg.src = "assets/worm-head.png"
        headImg.onload = function() {
            resetGame();
        } 

        let bodyImg = new Image();
        bodyImg.src = "assets/worm-body.png"

        let foodImg;
        
        function resetGame() {
            snake = [{x: 10, y: 10}];
            dx = 0;
            dy = 0;
            food = generateFood();
            score = 1;
            gameRunning = false;
            gameOverEl.style.display = 'none';
            updateScore();
            draw();
        }
        
        function generateFood() {
            let newFood;
            do {
                newFood = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
            } while (snake.some(segment => segment.x === newFood.x && segment.y === newFood.y));
            return newFood;
        }
        
        function draw() {
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const dayVal = dayMap.get(score);
            
            // Draw snake body first
            snake.forEach((segment, i) => {
                if (i > 0 && bodyImg) {
                    let segmentImg;
                    if (dayMap.get(i)) {
                        segmentImg = new Image();
                        segmentImg.src = `assets/${i}.png`
                    } else {
                        segmentImg = bodyImg;
                    }
                    // Draw body image (bigger, with overlap)
                    ctx.drawImage(segmentImg, 
                        segment.x * gridSize + imageOffset, 
                        segment.y * gridSize + imageOffset, 
                        imageSize, 
                        imageSize);
                } else if (i > 0) {
                    // Fallback to colored squares for body
                    ctx.fillStyle = '#8BC34A';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                }
            });
            
            // Draw head last so it overlaps body
            if (headImg) {
                ctx.save();
                
                // Calculate center of the head tile
                const centerX = snake[0].x * gridSize + gridSize / 2;
                const centerY = snake[0].y * gridSize + gridSize / 2;
                
                ctx.translate(centerX, centerY);
                
                // Rotate and flip based on direction
                if (dx === 1) {
                    // Moving right - flip horizontally
                    ctx.scale(-1, 1);
                } else if (dx === -1) {
                    // Moving left - no rotation
                    ctx.rotate(0);
                } else if (dy === 1) {
                    // Moving down
                    ctx.rotate(Math.PI / 2);
                } else if (dy === -1) {
                    // Moving up
                    ctx.rotate(-Math.PI / 2);
                }
                
                ctx.drawImage(headImg, 
                    -imageSize / 2, 
                    -imageSize / 2, 
                    imageSize, 
                    imageSize);
                
                ctx.restore();
            } else {
                // Fallback to colored square for head
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);
            }
            
            // Draw food
            if (foodImg) {
                ctx.drawImage(foodImg, 
                        food.x * gridSize + imageOffset, 
                        food.y * gridSize + imageOffset, 
                        imageSize, 
                        imageSize);
            } else {
                ctx.fillStyle = '#FF5722';
                ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
            }
        }
        
        function update() {
            // if (!gameRunning) return;
            
            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            
            // Check wall collision
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                endGame();
                return;
            }
            
            // Check self collision
            if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                endGame();
                return;
            }
            
            snake.unshift(head);
            
            // Check food collision
            if (head.x === food.x && head.y === food.y) {
                score++;
                updateScore();
                food = generateFood();
            } else {
                snake.pop();
            }
            
            draw();
        }
        
        function updateScore() {
            scoreEl.textContent = score;
            const dayVal = dayMap.get(score)
            if (dayVal) {
                dayEl.textContent = dayVal;
                foodImg = new Image();
                foodImg.src = `assets/${score}.png`
            } else {
                dayEl.textContent = noVal;
                foodImg = null;
            }

        }
        
        function endGame() {
            gameRunning = false;
            // gameOverEl.style.display = 'block';
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                resetGame();
                return;
            }
            
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
                e.preventDefault();
                // gameRunning = true;
            }
            
            switch(e.code) {
                case 'ArrowUp':
                    if (dy === 0) { dx = 0; dy = -1; }
                    break;
                case 'ArrowDown':
                    if (dy === 0) { dx = 0; dy = 1; }
                    break;
                case 'ArrowLeft':
                    if (dx === 0) { dx = -1; dy = 0; }
                    break;
                case 'ArrowRight':
                    if (dx === 0) { dx = 1; dy = 0; }
                    break;
            }
        });
        
        setInterval(update, gameSpeed);
        // resetGame();
    </script>
</body>
</html>